use crate::{substrate, Api};

pub async fn log_price_average(api: Api) -> Result<(), Box<dyn std::error::Error>> {
	let mut last_price_at = -1;
	loop {
		let last_finalized_block_hash = api.rpc().finalized_head().await?;
		let last_finalized_block = api.rpc().block(Some(last_finalized_block_hash)).await?.unwrap();
		let last_finalized_block_n = last_finalized_block.block.header.number;

		// storage address for Prices<T> on OCW example pallet
		let prices_addr = substrate::storage().ocw_example().prices();

		// time to log price average?
		if last_finalized_block_n as i32 > last_price_at {
			// current value of Prices<T>
			match api
				.storage()
				.at(Some(last_finalized_block_hash))
				.await?
				.fetch(&prices_addr)
				.await?
			{
				Some(prices) => {
					let sum: u32 = prices.0.clone().into_iter().sum();
					let n = prices.0.len();
					let avg = sum as f32 / n as f32;

					// prices are multiplied 100x while parsed before stored onchain
					// https://github.com/paritytech/substrate/blob/3a94009daac8919db46e3014964fe23866edb996/frame/examples/offchain-worker/src/lib.rs#L642
					log::info!("BTC/USD price average: {:.2}", avg / 100f32);
				},
				None => {},
			}

			last_price_at = last_finalized_block_n as i32;
		}
	}
}
